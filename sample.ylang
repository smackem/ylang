SobelX := [-1  0  1
           -2  0  2
           -1  0  1]
SobelY := [ 1  2  1
            0  0  0
           -1 -2 -1]

Laplace := [-1 -1 -1
            -1  8 -1
            -1 -1 -1]

Gauss := [0 1 2 1 0
          1 2 4 2 1
          2 4 8 4 2
          1 2 4 2 1
          0 1 2 1 0]

Median := kernel(5, 5, 1)
MedianCenter := 2;2

Greyscale := fn() {
    for pos in Bounds {
        @pos = White * @pos.sci
    }
    commit
}

Smoothen := fn() {
    for pos in Bounds {
        @pos = convolute(pos, Gauss)
    }
    commit
}

DetectEdges := fn() {
    Q0   := [0 0 0
             1 1 1
             0 0 0]
    Q45  := [0 0 1
             0 1 0
             1 0 0]
    Q90  := [0 1 0
             0 1 0
             0 1 0]
    Q135 := [1 0 0
             0 1 0
             0 0 1]

    for pos in Bounds {
        sx := convolute(pos, SobelX)
        sy := convolute(pos, SobelY)
        mag := sqrt(sx.r * sx.r + sy.r * sy.r)
        k := nil
        angle := sx.r == 0 ? 0 : atan(sy.r / sx.r) * 180 / Pi + 90
        if angle >= 157.5 or angle < 22.5 {
            k = Q90
        } else if angle < 67.5 {
            k = Q135
        } else if angle < 112.5 {
            k = Q0
        } else if angle < 157.5 {
            k = Q45
        }
        area := map_r(pos, k)
        if max(area) != area[4] {
            mag = 0
        }
        @pos = rgb(mag, mag, mag)
    }
    commit
}

Hysteresis := fn() {
    Neighbours := [1 1 1
                   1 1 1
                   1 1 1]
    for pos in Bounds {
        val := @pos.r
        if val > 10 {
            val = 255
        } else if val < 5 {
            val = 0
        } else {
            neighbours := map_r(pos, Neighbours)
            if max(neighbours) > 10 {
                val = 255
            } else {
                val = 0
            }
        }

        @pos = rgb(val, val, val)
    }
    commit
}

Greyscale()
Smoothen()
DetectEdges()
Hysteresis()
