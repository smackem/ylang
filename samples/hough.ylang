
///////////////////////////////////////////////////////////////////////////////
log("Greyscale, Smoothen...")

Gauss := gauss(7)

for p in Bounds {
    blurred := convolute(p, Gauss)
    @p = grey(blurred.i)
}

SourceImage := flip()

///////////////////////////////////////////////////////////////////////////////
log("Detect Edges...")

SobelX := |-1  0  1
           -2  0  2
           -1  0  1|
SobelY := | 1  2  1
            0  0  0
           -1 -2 -1|

for p in Bounds {
    gx := convolute(p, SobelX).r
    gy := convolute(p, SobelY).r
    mag := hypot(gx, gy)
    angle := atan(gy / gx)
    @p = mag > 200 ? grey(mag) : Black
}

flip()

///////////////////////////////////////////////////////////////////////////////
log("Accumulate...")

MaxRho := hypot(Bounds.w, Bounds.h)
log("MaxRho: ", MaxRho)
MaxTheta := 180 // degrees
Acc := kernel(MaxRho * 2, MaxTheta, 0)
for p in Bounds {
    if @p.r > 0 {
        for theta in 0 .. MaxTheta {
            thetaRad := theta * Deg2Rad
            rho := p.x * cos(thetaRad) + p.y * sin(thetaRad)
            accX := MaxRho + rho
            accY := theta
            weight := Acc[accX;accY] + 1
            Acc[accX;accY] = weight
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
log("Find Maxima, Visualize...")

outBounds := resize(Acc.w, Acc.h)
for p in outBounds {
    @p = grey(Acc[p.x;p.y])
}
flip()

k := kernel(11, 11, 1)
maxWeight := 0
for p in Bounds {
    neighbours := fetch_red(p, k)
    maximum := max_kernel(neighbours)
    @p = grey(@p.r == maximum ? @p.r : 0)
    maxWeight = max(maxWeight, maximum)
}
flip()

lines := []
threshold := maxWeight * 0.5
for p in Bounds {
    if @p.r > threshold {
        lines = lines :: {
            rho: p.x,
            theta: p.y,
        }
    }
}
log(lines)

DrawDot := fn(p, color) {
    rc := rect(p.x - 2, p.y - 2, 5, 5)
    for pp in rect(p.x - 2, p.y - 2, 5, 5) {
        if pp.x == rc.left and pp.y == rc.top
        or pp.x == rc.left and pp.y == rc.bottom-1
        or pp.x == rc.right-1 and pp.y == rc.top
        or pp.x == rc.right-1 and pp.y == rc.bottom-1 {
            // do nothing to round corners
        } else {
            @pp = color
        }
    }
}

//for line in lines {
//    DrawDot(line.rho;line.theta, #ff0000)
//}


///////////////////////////////////////////////////////////////////////////////
log("Draw Lines...")

recall(SourceImage)
outBounds := resize(Bounds.w, Bounds.h)
blt(Bounds)

for l in lines {
    // rho = x * cos(theta) + y * sin(theta)
    thetaRad := l.theta * Deg2Rad
    rho := l.rho - MaxRho
    lineToDraw := nil
    color := #00ff00
    if l.theta >= 45 and l.theta <= 135 {
        // line has low slope -> intersect with x borders
        // y = (rho - x * cos(theta)) / sin(theta)
        y1 := rho / sin(thetaRad)
        y2 := (rho - Bounds.w * cos(thetaRad)) / sin(thetaRad)
        lineToDraw = line(0;y1, Bounds.w;y2)
    } else {
        // line has high slope -> intersect with y borders
        // x = (rho - y * sin(theta)) / cos(theta)
        x1 := rho / cos(thetaRad)
        x2 := (rho - Bounds.h * sin(thetaRad)) / cos(thetaRad)
        lineToDraw = line(x1;0, x2;Bounds.h)
    }
    log(lineToDraw)
    for p in lineToDraw { @p = color }
}
